{% extends "base.html" %}

{% block head %}
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
{% endblock %}

{% block title %}HaoXai IDE - Notebook{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-darker.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    :root {
        --bg-primary: #1e1e1e;
        --bg-secondary: #252526;
        --bg-tertiary: #2d2d30;
        --bg-hover: #3e3e42;
        --bg-active: #37373d;
        --border-color: #3e3e42;
        --text-primary: #cccccc;
        --text-secondary: #858585;
        --text-muted: #6e7681;
        --accent-primary: #007acc;
        --accent-success: #89d185;
        --accent-warning: #cca700;
        --accent-danger: #f85149;
        --accent-info: #4fc1ff;
        --font-mono: 'Cascadia Code', 'Fira Code', 'SF Mono', Monaco, Consolas, monospace;
        --font-ui: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        --sidebar-width: 260px;
        --activity-bar-width: 48px;
        --tab-height: 35px;
    }

    * { box-sizing: border-box; }

    body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: var(--font-ui);
        margin: 0;
        overflow: hidden;
        font-size: 13px;
    }

    .ide-container {
        display: flex;
        height: 100vh;
        width: 100vw;
    }

    /* Activity Bar */
    .activity-bar {
        width: var(--activity-bar-width);
        background: var(--bg-secondary);
        border-right: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px 0;
        flex-shrink: 0;
    }

    .activity-item {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 4px;
        margin-bottom: 4px;
        transition: all 0.2s;
        position: relative;
    }

    .activity-item:hover { color: var(--text-primary); background: var(--bg-hover); }
    .activity-item.active { color: var(--text-primary); background: var(--bg-active); }
    .activity-item.active::before {
        content: '';
        position: absolute;
        left: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 2px;
        height: 20px;
        background: var(--text-primary);
        border-radius: 0 2px 2px 0;
    }
    .activity-item i { font-size: 20px; }
    .activity-bottom { margin-top: auto; }

    /* Sidebar */
    .sidebar {
        width: var(--sidebar-width);
        background: var(--bg-secondary);
        border-right: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
    }

    .sidebar-header {
        padding: 10px 15px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-secondary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
    }

    .sidebar-section { margin-bottom: 12px; }
    .sidebar-section-title {
        padding: 6px 15px;
        font-size: 11px;
        color: var(--text-muted);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
    }
    .sidebar-section-title:hover { color: var(--text-primary); }

    /* File Tree */
    .file-tree { font-size: 13px; }
    .file-item {
        display: flex;
        align-items: center;
        padding: 4px 15px 4px 20px;
        cursor: pointer;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-item:hover { background: var(--bg-hover); }
    .file-item.selected { background: var(--bg-active); }
    .file-item i { width: 16px; margin-right: 6px; font-size: 14px; }
    .file-item.directory i { color: var(--accent-info); }
    .file-item.file i { color: var(--text-secondary); }
    .file-item .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; }

    /* Main Editor Area */
    .editor-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--bg-primary);
    }

    /* Tab Bar */
    .tab-bar {
        height: var(--tab-height);
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        overflow-x: auto;
        padding: 0 8px;
    }
    .tab {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-bottom: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 12px;
        min-width: 120px;
        max-width: 200px;
        white-space: nowrap;
    }
    .tab:hover { color: var(--text-primary); background: var(--bg-hover); }
    .tab.active {
        color: var(--text-primary);
        background: var(--bg-primary);
        border-top: 2px solid var(--accent-primary);
    }
    .tab i { font-size: 12px; }
    .tab-close { margin-left: auto; padding: 2px 4px; border-radius: 3px; }
    .tab-close:hover { background: var(--accent-danger); color: white; }

    /* Toolbar */
    .toolbar {
        height: 40px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        padding: 0 12px;
        gap: 8px;
    }
    .toolbar-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 12px;
        border-radius: 4px;
        transition: all 0.2s;
    }
    .toolbar-btn:hover { background: var(--bg-hover); border-color: var(--text-muted); }
    .toolbar-btn.primary { background: var(--accent-primary); border-color: var(--accent-primary); }
    .toolbar-btn.primary:hover { background: #0066aa; }
    .toolbar-btn.success {
        background: rgba(137, 209, 133, 0.2);
        border-color: var(--accent-success);
        color: var(--accent-success);
    }
    .toolbar-btn.success:hover { background: rgba(137, 209, 133, 0.3); }
    .toolbar-separator { width: 1px; height: 20px; background: var(--border-color); margin: 0 4px; }

    /* Editor Content */
    .editor-content {
        flex: 1;
        overflow: auto;
        padding: 20px;
    }
    .notebook-cells {
        max-width: 900px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 16px;
    }

    /* Cell Styles */
    .cell {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow: hidden;
    }
    .cell:hover { border-color: var(--bg-hover); }
    .cell.active { border-color: var(--accent-primary); }
    .cell-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 10px;
        background: var(--bg-tertiary);
        border-bottom: 1px solid var(--border-color);
    }
    .cell-type-selector { display: flex; gap: 2px; }
    .cell-type-btn {
        padding: 3px 10px;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 11px;
        border-radius: 3px;
        font-weight: 500;
    }
    .cell-type-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
    .cell-type-btn.active { color: var(--text-primary); background: var(--accent-primary); }
    .cell-actions { display: flex; gap: 4px; }
    .cell-action-btn {
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
    }
    .cell-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .cell-editor { min-height: 60px; }
    .cell-editor .CodeMirror {
        height: auto !important;
        min-height: 60px;
        background: var(--bg-secondary);
        font-family: var(--font-mono);
        font-size: 14px;
        line-height: 1.6;
    }
    .cell-output {
        border-top: 1px solid var(--border-color);
        background: var(--bg-primary);
        display: none;
    }
    .cell-output.show { display: block; }
    .output-header {
        padding: 6px 10px;
        font-size: 11px;
        color: var(--text-muted);
        background: var(--bg-tertiary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .output-content {
        padding: 12px;
        max-height: 300px;
        overflow: auto;
        font-family: var(--font-mono);
        font-size: 13px;
    }

    /* Package Panel */
    .package-panel { padding: 12px; }
    .package-input-group { display: flex; gap: 8px; margin-bottom: 12px; }
    .package-input {
        flex: 1;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 8px 12px;
        font-size: 13px;
        font-family: var(--font-mono);
        border-radius: 4px;
    }
    .package-input:focus { outline: none; border-color: var(--accent-primary); }
    .package-output {
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        padding: 12px;
        border-radius: 4px;
        font-size: 12px;
        min-height: 80px;
        max-height: 120px;
        overflow: auto;
    }
    .package-language-selector {
        display: flex;
        gap: 4px;
        margin-bottom: 12px;
    }
    .package-lang-btn {
        flex: 1;
        padding: 8px 12px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 4px;
        font-size: 12px;
        transition: all 0.2s ease;
    }
    .package-lang-btn:hover {
        background: var(--bg-hover);
        color: var(--text-primary);
    }
    .package-lang-btn.active {
        background: var(--accent-primary);
        color: white;
        border-color: var(--accent-primary);
    }
    .r-config-section {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 12px;
    }
    .config-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 8px;
    }
    .config-input-group {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
    }
    .config-input-group label {
        font-size: 11px;
        color: var(--text-secondary);
        min-width: 80px;
    }
    .config-input {
        flex: 1;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 6px 8px;
        font-size: 11px;
        font-family: var(--font-mono);
        border-radius: 3px;
    }
    .config-input:focus {
        outline: none;
        border-color: var(--accent-primary);
    }
    .config-btn {
        padding: 6px 8px;
        background: var(--accent-primary);
        border: none;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.2s ease;
    }
    .config-btn:hover {
        background: var(--accent-hover);
    }
    .config-help {
        color: var(--text-muted);
        font-style: italic;
    }

    /* Add Cell Button */
    .add-cell-container { display: flex; justify-content: center; padding: 12px 0; }
    .add-cell-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px 16px;
        background: var(--bg-tertiary);
        border: 1px dashed var(--border-color);
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 12px;
        border-radius: 4px;
        transition: all 0.2s;
    }
    .add-cell-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); }

    /* Status Bar */
    .status-bar {
        height: 22px;
        background: var(--accent-primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        font-size: 12px;
    }
    .status-item { display: flex; align-items: center; gap: 6px; }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--bg-hover); }

    /* Schema Tree */
    .schema-tree { font-size: 13px; }
    .schema-item {
        padding: 4px 15px;
        cursor: pointer;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 6px;
    }
    .schema-item:hover { background: var(--bg-hover); }
    .schema-item i { color: var(--accent-primary); font-size: 12px; }

    .file-item { padding: 4px 15px; cursor: pointer; color: var(--text-primary); display: flex; align-items: center; gap: 8px; }
    .file-item:hover { background: var(--bg-hover); }
    .file-item.directory { font-weight: 600; }
    .file-item i { width: 16px; text-align: center; color: var(--accent-primary); }

    .file-breadcrumb {
        padding: 6px 15px;
        font-size: 12px;
        color: var(--text-muted);
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    .file-breadcrumb:hover {
        background: var(--bg-hover);
    }

    .workspace-info {
        padding: 6px 15px;
        font-size: 11px;
        color: var(--text-muted);
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
    }

    .output-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        font-family: var(--font-mono);
    }
    .output-table th {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        padding: 8px 12px;
        text-align: left;
        font-weight: 600;
        border-bottom: 2px solid var(--accent-primary);
    }
    .output-table td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-secondary);
    }
    .output-table tr:hover td { background: var(--bg-hover); }
    .output-success { color: var(--accent-success); padding: 8px 0; }
    .output-error { color: var(--accent-danger); padding: 8px 0; }
    .output-text { font-family: var(--font-mono); font-size: 13px; line-height: 1.5; white-space: pre-wrap; }
</style>
{% endblock %}

{% block content %}
<div class="ide-container">
    <!-- Activity Bar -->
    <div class="activity-bar">
        <div class="activity-item active" onclick="showSidebar('files')" title="Explorer">
            <i class="fas fa-folder-open"></i>
        </div>
        <div class="activity-item" onclick="showSidebar('search')" title="Search">
            <i class="fas fa-search"></i>
        </div>
        <div class="activity-item" onclick="showSidebar('packages')" title="Packages">
            <i class="fas fa-cube"></i>
        </div>
        <div class="activity-item" onclick="showSidebar('database')" title="Database">
            <i class="fas fa-database"></i>
        </div>
        <div class="activity-bottom">
            <div class="activity-item" onclick="toggleSettings()" title="Settings">
                <i class="fas fa-cog"></i>
            </div>
        </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <!-- Explorer View -->
        <div id="sidebar-files" class="sidebar-view">
            <div class="sidebar-header">
                <span>Explorer</span>
                <div>
                    <i class="fas fa-folder-plus" style="cursor: pointer; margin-right: 8px;" onclick="createNewFolder()" title="New Folder"></i>
                    <i class="fas fa-upload" style="cursor: pointer;" onclick="triggerFileUpload()" title="Upload"></i>
                </div>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <div class="sidebar-section-title" onclick="toggleSection(this)">
                        <i class="fas fa-chevron-down"></i> Workspace
                    </div>
                    <div class="file-breadcrumb" id="file-breadcrumb" onclick="navigateToParent()" title="Click to go up">/</div>
                    <div class="workspace-info" id="workspace-info">Loading...</div>
                    <div class="file-tree" id="file-browser">
                        <div style="padding: 12px; color: var(--text-muted); text-align: center;">Loading...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Package Manager View -->
        <div id="sidebar-packages" class="sidebar-view" style="display: none;">
            <div class="sidebar-header"><span>Package Manager</span></div>
            <div class="sidebar-content package-panel">
                <div class="package-language-selector">
                    <button class="package-lang-btn active" onclick="setPackageLanguage('python')" data-lang="python">Python</button>
                    <button class="package-lang-btn" onclick="setPackageLanguage('r')" data-lang="r">R</button>
                </div>
                
                <!-- R Configuration Section -->
                <div id="r-config-section" class="r-config-section" style="display: none;">
                    <div class="config-header">
                        <i class="fas fa-cog"></i> R Configuration
                    </div>
                    <div class="config-input-group">
                        <label for="r-path-input">Rscript Path:</label>
                        <input type="text" id="r-path-input" class="config-input" 
                               placeholder="C:\Program Files\R\R-4.5.2\bin\x64\Rscript.exe"
                               value="">
                        <button class="config-btn" onclick="saveRPath()">
                            <i class="fas fa-save"></i>
                        </button>
                    </div>
                    <div class="config-help">
                        <small>Path to Rscript.exe (usually in R\bin\x64 folder)</small>
                    </div>
                </div>
                
                <div class="package-input-group">
                    <input type="text" class="package-input" id="pip-package-input" placeholder="numpy, pandas...">
                    <button class="toolbar-btn primary" onclick="installPackage()">
                        <i class="fas fa-download"></i>
                    </button>
                </div>
                <div id="pip-output" class="package-output" style="display: none;"></div>
            </div>
        </div>

        <!-- Database View -->
        <div id="sidebar-database" class="sidebar-view" style="display: none;">
            <div class="sidebar-header"><span>Database Schema</span></div>
            <div class="sidebar-content">
                <div class="schema-tree" id="schema-list">
                    <div style="padding: 12px; color: var(--text-muted); text-align: center;">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Editor Area -->
    <div class="editor-area">
        <!-- Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab active">
                <i class="fas fa-book"></i>
                <span>notebook.ipynb</span>
                <span class="tab-close" onclick="event.stopPropagation()">x</span>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button class="toolbar-btn success" onclick="runCurrentCell()">
                <i class="fas fa-play"></i> Run
            </button>
            <button class="toolbar-btn" onclick="runAllCells()">
                <i class="fas fa-forward"></i> Run All
            </button>
            <div class="toolbar-separator"></div>
            <button class="toolbar-btn" onclick="addNewCell()">
                <i class="fas fa-plus"></i> Add Cell
            </button>
            <button class="toolbar-btn" onclick="clearAllOutputs()">
                <i class="fas fa-eraser"></i> Clear
            </button>
            <div class="toolbar-separator"></div>
            <button class="toolbar-btn primary" onclick="saveNotebook()">
                <i class="fas fa-save"></i> Save
            </button>
        </div>

        <!-- Editor Content -->
        <div class="editor-content">
            <div class="notebook-cells" id="notebook-cells">
                <!-- Cells rendered here -->
            </div>
            <div class="add-cell-container">
                <button class="add-cell-btn" onclick="addNewCell()">
                    <i class="fas fa-plus"></i> Add New Cell
                </button>
            </div>
        </div>
    </div>
</div>

<input type="file" id="file-upload-input" style="display: none;" onchange="handleFileUpload(this)">
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/sql/sql.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/r/r.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/sql-hint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/python-hint.min.js"></script>
<script>
    // Safe JSON parsing function
    function safeJSONParse(response, context) {
        try {
            // Replace NaN with null to make valid JSON
            const cleanedResponse = response.replace(/\bNaN\b/g, 'null');
            return JSON.parse(cleanedResponse);
        } catch (e) {
            console.error(`JSON parse error in ${context}:`, e);
            console.error('Response:', response);
            return null;
        }
    }
    
    let cells = [];
    let activeCellId = null;
    let cellIdCounter = 0;
    let databaseTables = [];
    let tableColumns = {}; // Store table columns for better autocomplete

    // Custom SQL autocomplete with database tables
    CodeMirror.registerHelper('hint', 'sql', function(editor, options) {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const start = cursor.ch;
        const end = cursor.ch;
        
        // Better word detection - handle different word boundaries and partial keywords
        const textBeforeCursor = line.substring(0, start);
        const wordMatch = textBeforeCursor.match(/\w*$/);
        const word = wordMatch ? wordMatch[0] : '';
        
        // Check if we're typing within a keyword (like "f" in "FROM")
        const fullLineBeforeCursor = line.substring(0, start);
        const lastSpaceIndex = fullLineBeforeCursor.lastIndexOf(' ');
        const lastWord = lastSpaceIndex >= 0 ? fullLineBeforeCursor.substring(lastSpaceIndex + 1) : fullLineBeforeCursor;
        
        // Check if we're after a semicolon in the current line - stop autocomplete
        const currentLineUpToCursor = line.substring(0, start);
        if (currentLineUpToCursor.includes(';')) {
            return { list: [], from: CodeMirror.Pos(cursor.line, start), to: CodeMirror.Pos(cursor.line, end) };
        }
        
        // Debug logging
        console.log('SQL Autocomplete Debug:', {
            word: word,
            lastWord: lastWord,
            textBeforeCursor: textBeforeCursor,
            fullLineBeforeCursor: fullLineBeforeCursor,
            databaseTables: databaseTables.length,
            tableColumns: Object.keys(tableColumns).length
        });
        // Get context for better suggestions
        const context = textBeforeCursor.toLowerCase();
        
        const sqlKeywords = [
            // Basic DML/DQL
            'SELECT', 'FROM', 'WHERE', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER',
            // Joins
            'JOIN', 'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS', 'ON', 'USING',
            // Logical operators
            'AND', 'OR', 'NOT', 'IN', 'NOT IN', 'EXISTS', 'NOT EXISTS', 'BETWEEN', 'LIKE', 'ILIKE', 'IS', 'IS NOT',
            // Comparison operators
            '=', '!=', '<>', '<', '>', '<=', '>=',
            // Aggregation
            'GROUP', 'BY', 'HAVING', 'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',
            // Ordering
            'ORDER', 'ASC', 'DESC', 'LIMIT', 'OFFSET',
            // Set operations
            'UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT', 'MINUS',
            // Subqueries
            'WITH', 'AS', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
            // Data types and NULL handling
            'NULL', 'NOT NULL', 'DEFAULT', 'PRIMARY', 'KEY', 'FOREIGN', 'REFERENCES',
            'INTEGER', 'TEXT', 'REAL', 'BLOB', 'VARCHAR', 'CHAR', 'DATE', 'DATETIME', 'TIMESTAMP',
            'BOOLEAN', 'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE',
            // Constraints
            'UNIQUE', 'CHECK', 'CONSTRAINT', 'INDEX', 'TRIGGER', 'VIEW',
            // DDL
            'TABLE', 'DATABASE', 'SCHEMA', 'INDEX', 'SEQUENCE', 'PROCEDURE', 'FUNCTION',
            // Transaction
            'BEGIN', 'COMMIT', 'ROLLBACK', 'TRANSACTION', 'SAVEPOINT',
            // Modifiers
            'DISTINCT', 'ALL', 'ANY', 'SOME', 'TOP', 'PERCENT',
            // Window functions
            'OVER', 'PARTITION', 'ROWS', 'RANGE', 'UNBOUNDED', 'PRECEDING', 'FOLLOWING', 'CURRENT', 'ROW',
            'FIRST_VALUE', 'LAST_VALUE', 'LAG', 'LEAD', 'ROW_NUMBER', 'RANK', 'DENSE_RANK',
            // Conditional
            'IF', 'NULLIF', 'COALESCE', 'ISNULL',
            // String functions
            'SUBSTRING', 'SUBSTR', 'LENGTH', 'LEN', 'UPPER', 'LOWER', 'TRIM', 'LTRIM', 'RTRIM',
            'CONCAT', 'REPLACE', 'INSTR', 'POSITION', 'LOCATE', 'CHARINDEX',
            // Date functions
            'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',
            'EXTRACT', 'DATE_PART', 'DATE_TRUNC', 'ADD_DATE', 'SUB_DATE',
            // Math functions
            'ABS', 'CEIL', 'FLOOR', 'ROUND', 'MOD', 'POWER', 'SQRT', 'EXP', 'LOG',
            'SIN', 'COS', 'TAN', 'ASIN', 'ACOS', 'ATAN',
            // Other
            'CAST', 'CONVERT', 'TRY_CAST', 'TRY_CONVERT',
            'PI', 'RANDOM', 'ROWID', 'AUTOINCREMENT'
        ];
        
        const sqlFunctions = [
            // Aggregate functions
            'COUNT()', 'SUM()', 'AVG()', 'MIN()', 'MAX()', 'TOTAL()', 'GROUP_CONCAT()',
            // String functions
            'LENGTH()', 'UPPER()', 'LOWER()', 'TRIM()', 'LTRIM()', 'RTRIM()', 'SUBSTR()', 'SUBSTRING()',
            'REPLACE()', 'INSTR()', 'LPAD()', 'RPAD()', 'CONCAT()', 'CONCAT_WS()',
            // Numeric functions
            'ABS()', 'ROUND()', 'CEIL()', 'FLOOR()', 'SQRT()', 'POWER()', 'MOD()', 'RAND()', 'RANDOM()',
            'EXP()', 'LOG()', 'LOG10()', 'LN()', 'PI()', 'SIN()', 'COS()', 'TAN()', 'ASIN()', 'ACOS()', 'ATAN()',
            // Date/Time functions
            'DATE()', 'TIME()', 'DATETIME()', 'NOW()', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',
            'strftime()', 'julianday()', 'unixepoch()', 'date()', 'time()', 'datetime()',
            'strftime()', 'STRFTIME()', 'MODIFIED()', 'ADDDATE()', 'SUBDATE()',
            // Conditional functions
            'COALESCE()', 'NULLIF()', 'IFNULL()', 'IIF()', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
            // Type conversion
            'CAST()', 'TYPEOF()', 'PRINTF()', 'QUOTE()',
            // JSON functions (SQLite 3.38+)
            'JSON()', 'JSON_ARRAY()', 'JSON_OBJECT()', 'JSON_EXTRACT()', 'JSON_INSERT()', 'JSON_REPLACE()',
            'JSON_REMOVE()', 'JSON_SET()', 'JSON_PATCH()', 'JSON_VALID()', 'JSON_QUOTE()', 'JSON_GROUP_ARRAY()',
            // Window functions
            'ROW_NUMBER()', 'RANK()', 'DENSE_RANK()', 'PERCENT_RANK()', 'CUME_DIST()', 'NTILE()',
            'LAG()', 'LEAD()', 'FIRST_VALUE()', 'LAST_VALUE()', 'NTH_VALUE()',
            // Other utility functions
            'CHANGES()', 'LAST_INSERT_ROWID()', 'SQLITE_VERSION()', 'HEX()', 'UNHEX()', 'ZEROBLOB()'
        ];
        
        // Common column names from screening database
        const commonColumns = [
            'screening_id', 'tested_sample_id', 'excel_id', 'team', 'sample_type',
            'pan_corona', 'pan_hanta', 'pan_paramyxo', 'pan_flavi', 'created_at',
            'sample_id', 'source_id', 'sample_origin', 'collection_date', 'tissue_id',
            'blood_id', 'saliva_id', 'host_id', 'host_type', 'field_id', 'bag_id',
            'sex', 'status', 'capture_date', 'taxonomy_id', 'scientific_name',
            'common_name', 'genus', 'species', 'family', 'order_name', 'location_id',
            'province', 'district', 'village', 'site_name', 'latitude', 'longitude',
            'env_sample_id', 'pool_id', 'collection_method', 'rack', 'spot_position'
        ];
        
        let suggestions = [
            ...sqlKeywords.map(k => ({text: k, displayText: k + ' (keyword)', type: 'keyword'})),
            ...sqlFunctions.map(f => ({text: f, displayText: f + ' (function)', type: 'function'})),
            ...commonColumns.map(c => ({text: c, displayText: c + ' (column)', type: 'column'}))
        ];
        
        // Add table names
        databaseTables.forEach(table => {
            suggestions.push({text: table, displayText: table + ' (table)', type: 'table'});
            
            // Add table columns if available
            if (tableColumns[table]) {
                tableColumns[table].forEach(col => {
                    suggestions.push({text: col, displayText: `${table}.${col} (column)`, type: 'column'});
                });
            }
        });
        
        // Better context-aware filtering with case-insensitive detection
        const tokens = textBeforeCursor.trim().split(/\s+/);
        const lastToken = tokens[tokens.length - 1];
        const secondLastToken = tokens[tokens.length - 2];
        
        // Helper function to check if tokens contain a keyword (case-insensitive)
        const hasKeyword = (keyword) => {
            return tokens.some(token => token.toUpperCase() === keyword);
        };
        
        // Helper function to detect table aliases and their corresponding tables
        const detectTableAlias = (tokens) => {
            const aliasMap = {};
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                const nextToken = tokens[i + 1];
                
                // Look for patterns like "samples s" or "hosts h"
                if (databaseTables.includes(token) && nextToken && !hasKeyword(nextToken)) {
                    aliasMap[nextToken] = token;
                }
            }
            return aliasMap;
        };
        
        // Check if we're typing after a table alias (like "s." or "h.")
        const aliasMatch = textBeforeCursor.match(/(\w+)\.$/);
        if (aliasMatch) {
            const alias = aliasMatch[1];
            const aliasMap = detectTableAlias(tokens);
            const actualTable = aliasMap[alias];
            
            if (actualTable && tableColumns[actualTable]) {
                // Show columns for the aliased table
                suggestions = tableColumns[actualTable].map(col => ({
                    text: col,
                    displayText: `${col} (column from ${actualTable})`,
                    type: 'column'
                }));
            } else if (actualTable) {
                // Fallback to common columns if table columns not loaded
                suggestions = commonColumns.map(col => ({
                    text: col,
                    displayText: `${col} (column)`,
                    type: 'column'
                }));
            } else {
                // Unknown alias, show common columns
                suggestions = commonColumns.map(col => ({
                    text: col,
                    displayText: `${col} (column)`,
                    type: 'column'
                }));
            }
        } else
        // Very restrictive context detection - only show what can come next
        if (tokens.length === 0 || (tokens.length === 1 && word.length > 0)) {
            // Beginning of query - only show main keywords that start with the word
            suggestions = suggestions.filter(s => 
                ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER', 'WITH'].includes(s.text) &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        } else if (hasKeyword('SELECT') && !hasKeyword('FROM')) {
            // After SELECT but before FROM - check if we're typing FROM
            if (lastWord.toLowerCase().startsWith('f')) {
                // Typing FROM - show FROM keyword
                suggestions = suggestions.filter(s => 
                    s.text === 'FROM' && s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            } else {
                // Show columns, functions, or * that match
                suggestions = suggestions.filter(s => 
                    (s.type === 'column' || s.type === 'function' || s.text === '*') &&
                    s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            }
        } else if (hasKeyword('FROM') && !hasKeyword('WHERE') && !hasKeyword('JOIN') && !hasKeyword('GROUP') && !hasKeyword('ORDER')) {
            // After FROM, check if we have a complete table name
            const fromIndex = tokens.findIndex(token => token.toUpperCase() === 'FROM');
            const tokensAfterFrom = tokens.slice(fromIndex + 1);
            
            // Check if the last token after FROM is a complete table name
            const lastTokenAfterFrom = tokensAfterFrom[tokensAfterFrom.length - 1];
            const isCompleteTableName = databaseTables.includes(lastTokenAfterFrom) || 
                                       commonColumns.some(col => col === lastTokenAfterFrom);
            
            if (tokensAfterFrom.length === 0 || !isCompleteTableName || word.length > 0) {
                // Just typed FROM or typing table name - only show tables that match
                suggestions = suggestions.filter(s => 
                    s.type === 'table' &&
                    s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            } else {
                // After complete table name - only show next logical keywords that match
                suggestions = suggestions.filter(s => 
                    ['WHERE', 'JOIN', 'INNER', 'LEFT', 'RIGHT', 'OUTER', 'GROUP', 'ORDER', 'LIMIT', 'HAVING'].includes(s.text) &&
                    s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            }
        } else if (hasKeyword('WHERE')) {
            // In WHERE clause - show columns, functions, AND logical operators that match
            suggestions = suggestions.filter(s => 
                (s.type === 'column' || s.type === 'function' || 
                ['AND', 'OR', 'NOT', 'IN', 'NOT IN', 'EXISTS', 'NOT EXISTS', 'BETWEEN', 'LIKE', 'ILIKE', 'IS', 'IS NOT', 'NULL', 'NOT NULL', '=', '!=', '<>', '<', '>', '<=', '>=', 'LIMIT', 'ORDER', 'GROUP', 'HAVING'].includes(s.text)) &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        } else if (hasKeyword('JOIN') || hasKeyword('INNER') || hasKeyword('LEFT') || hasKeyword('RIGHT') || hasKeyword('OUTER')) {
            // In JOIN clause
            if (!hasKeyword('ON')) {
                // Need table name or ON keyword that match
                suggestions = suggestions.filter(s => 
                    (s.type === 'table' || s.text === 'ON') &&
                    s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            } else {
                // After ON - only show columns and comparison operators that match
                suggestions = suggestions.filter(s => 
                    (s.type === 'column' || ['=', '!=', '<>', '<', '>', '<=', '>=', 'AND', 'OR'].includes(s.text)) &&
                    s.text.toLowerCase().startsWith(word.toLowerCase())
                );
            }
        } else if (hasKeyword('GROUP') && hasKeyword('BY')) {
            // After GROUP BY - only show columns that match
            suggestions = suggestions.filter(s => 
                s.type === 'column' &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        } else if (hasKeyword('ORDER') && hasKeyword('BY')) {
            // After ORDER BY - only show columns and ASC/DESC that match
            suggestions = suggestions.filter(s => 
                (s.type === 'column' || ['ASC', 'DESC'].includes(s.text)) &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        } else if (hasKeyword('HAVING')) {
            // After HAVING - only show columns, functions, and logical operators that match
            suggestions = suggestions.filter(s => 
                (s.type === 'column' || s.type === 'function' || ['AND', 'OR', 'NOT'].includes(s.text)) &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        } else if (hasKeyword('LIMIT')) {
            // After LIMIT - don't show anything (user types number)
            suggestions = [];
        } else {
            // Default: show keywords that match
            suggestions = suggestions.filter(s => 
                s.type === 'keyword' &&
                s.text.toLowerCase().startsWith(word.toLowerCase())
            );
        }
        
        // Debug logging
        console.log('SQL Autocomplete Results:', {
            totalSuggestions: suggestions.length,
            filteredCount: suggestions.length,
            word: word,
            showing: suggestions.slice(0, 5).map(s => s.text)
        });
        
        return {
            list: suggestions.slice(0, 20), // Limit to 20 suggestions
            from: CodeMirror.Pos(cursor.line, start - word.length),
            to: CodeMirror.Pos(cursor.line, end)
        };
    });

    // Register hint for text/x-sql mode
    CodeMirror.registerHelper('hint', 'text/x-sql', function(editor, options) {
        return CodeMirror.hint.sql(editor, options);
    });

    // Custom Python autocomplete
    CodeMirror.registerHelper('hint', 'python', function(editor, options) {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const start = cursor.ch;
        const end = cursor.ch;
        
        // Better word detection - handle different word boundaries
        const textBeforeCursor = line.substring(0, start);
        const wordMatch = textBeforeCursor.match(/\w*$/);
        const word = wordMatch ? wordMatch[0] : '';
        
        // Get context for better suggestions
        const context = textBeforeCursor.toLowerCase();
        
        const pythonKeywords = [
            'def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except', 'finally',
            'with', 'import', 'from', 'as', 'return', 'yield', 'lambda', 'pass', 'break',
            'continue', 'global', 'nonlocal', 'assert', 'del', 'raise', 'and', 'or', 'not',
            'in', 'is', 'None', 'True', 'False', 'async', 'await', 'match', 'case'
        ];
        
        const pythonLibs = [
            // Data science
            'pandas', 'pd', 'numpy', 'np', 'matplotlib', 'plt', 'seaborn', 'sns', 'plotly', 'bokeh',
            // Machine learning
            'sklearn', 'scipy', 'statsmodels', 'xgboost', 'lightgbm', 'tensorflow', 'tf', 'torch',
            // Database
            'sqlite3', 'sqlalchemy', 'psycopg2', 'pymongo', 'redis', 'elasticsearch',
            // Web/API
            'requests', 'urllib', 'httpx', 'aiohttp', 'flask', 'django', 'fastapi',
            // File handling
            'openpyxl', 'xlrd', 'xlwt', 'csv', 'json', 'yaml', 'pickle', 'joblib',
            // Standard library
            'os', 'sys', 'pathlib', 'datetime', 'time', 'collections', 'itertools', 'functools',
            'operator', 'math', 'random', 're', 'string', 'typing', 'dataclasses', 'enum',
            'logging', 'unittest', 'pytest', 'concurrent', 'multiprocessing', 'threading',
            'asyncio', 'subprocess', 'shutil', 'tempfile', 'glob', 'fnmatch',
            // Scientific computing
            'scipy', 'skimage', 'opencv', 'cv2', 'PIL', 'Image', 'nltk', 'spacy',
            'gensim', 'wordcloud', 'networkx', 'igraph', 'geopandas', 'folium'
        ];
        
        const pandasMethods = [
            // Reading/writing data
            'read_csv()', 'read_excel()', 'read_json()', 'read_sql()', 'read_parquet()', 'read_hdf()',
            'DataFrame()', 'Series()', 'to_csv()', 'to_excel()', 'to_json()', 'to_sql()', 'to_parquet()',
            'to_dict()', 'to_numpy()', 'to_list()', 'to_records()', 'to_markdown()',
            // Data manipulation
            'merge()', 'concat()', 'join()', 'append()', 'combine()', 'combine_first()',
            'groupby()', 'pivot_table()', 'crosstab()', 'melt()', 'stack()', 'unstack()',
            'explode()', 'squeeze()', 'repeat()', 'tile()', 'get_dummies()', 'cut()', 'qcut()',
            // Selection and filtering
            'head()', 'tail()', 'sample()', 'nlargest()', 'nsmallest()', 'loc', 'iloc', 'at', 'iat',
            'query()', 'eval()', 'filter()', 'where()', 'mask()', 'select_dtypes()',
            'xs()', 'get()', 'lookup()', 'isin()', 'between()', 'isna()', 'isnull()', 'notna()', 'notnull()',
            // Data cleaning
            'drop()', 'dropna()', 'fillna()', 'replace()', 'interpolate()', 'ffill()', 'bfill()',
            'duplicated()', 'drop_duplicates()', 'unique()', 'nunique()', 'value_counts()',
            'astype()', 'infer_objects()', 'convert_dtypes()', 'copy()', 'inplace',
            // Statistics and aggregation
            'describe()', 'info()', 'count()', 'sum()', 'mean()', 'median()', 'mode()', 'std()', 'var()',
            'min()', 'max()', 'quantile()', 'rank()', 'pct_change()', 'cumsum()', 'cumprod()', 'cummax()', 'cummin()',
            'corr()', 'cov()', 'skew()', 'kurtosis()', 'mad()', 'sem()', 'aggregate()', 'agg()',
            // Index operations
            'set_index()', 'reset_index()', 'reindex()', 'reindex_like()', 'rename()', 'rename_axis()',
            'sort_index()', 'sort_values()', 'argsort()', 'nlargest()', 'nsmallest()',
            'index', 'columns', 'values', 'dtypes', 'shape', 'size', 'ndim',
            // Time series
            'resample()', 'asfreq()', 'shift()', 'tshift()', 'diff()', 'pct_change()',
            'rolling()', 'expanding()', 'ewm()', 'to_datetime()', 'to_timedelta()', 'to_period()',
            'tz_localize()', 'tz_convert()', 'dt', 'dt accessor',
            // String operations
            'str', 'str.lower()', 'str.upper()', 'str.strip()', 'str.replace()', 'str.contains()',
            'str.startswith()', 'str.endswith()', 'str.split()', 'str.join()', 'str.extract()',
            'str.get_dummies()', 'str.cat()', 'str.slice()', 'str.pad()', 'str.wrap()',
            // Plotting
            'plot()', 'plot.line()', 'plot.bar()', 'plot.barh()', 'plot.hist()', 'plot.box()',
            'plot.kde()', 'plot.density()', 'plot.area()', 'plot.scatter()', 'plot.hexbin()',
            'plot.pie()', 'style', 'set_style()', 'set_theme()'
        ];
        
        const numpyMethods = [
            'array()', 'arange()', 'linspace()', 'zeros()', 'ones()', 'empty()',
            'reshape()', 'transpose()', 'dot()', 'sum()', 'mean()', 'std()', 'var()',
            'min()', 'max()', 'argmin()', 'argmax()', 'sqrt()', 'exp()', 'log()',
            'sin()', 'cos()', 'tan()', 'concatenate()', 'vstack()', 'hstack()',
            'unique()', 'where()', 'isnan()', 'isinf()', 'abs()', 'round()'
        ];
        
        const matplotlibMethods = [
            'figure()', 'subplot()', 'plot()', 'scatter()', 'bar()', 'hist()',
            'boxplot()', 'imshow()', 'show()', 'savefig()', 'title()', 'xlabel()',
            'ylabel()', 'legend()', 'grid()', 'xlim()', 'ylim()', 'xticks()',
            'yticks()', 'colormap()', 'colorbar()', 'text()', 'annotate()'
        ];
        
        const sqliteMethods = [
            'connect()', 'cursor()', 'execute()', 'executemany()', 'fetchall()',
            'fetchone()', 'fetchmany()', 'commit()', 'rollback()', 'close()'
        ];
        
        let suggestions = [
            ...pythonKeywords.map(k => ({text: k, displayText: k + ' (keyword)', type: 'keyword'})),
            ...pythonLibs.map(l => ({text: l, displayText: l + ' (library)', type: 'library'})),
            ...pandasMethods.map(m => ({text: m, displayText: m + ' (pandas)', type: 'pandas'})),
            ...numpyMethods.map(m => ({text: m, displayText: m + ' (numpy)', type: 'numpy'})),
            ...matplotlibMethods.map(m => ({text: m, displayText: m + ' (matplotlib)', type: 'matplotlib'})),
            ...sqliteMethods.map(m => ({text: m, displayText: m + ' (sqlite)', type: 'sqlite'}))
        ];
        
        // Context-aware filtering
        if (context.includes('import') || context.includes('from')) {
            // After import, suggest libraries
            suggestions = suggestions.filter(s => s.type === 'library');
        } else if (context.includes('pd.') || context.includes('pandas.')) {
            // After pd. or pandas., suggest pandas methods
            suggestions = suggestions.filter(s => s.type === 'pandas');
        } else if (context.includes('np.') || context.includes('numpy.')) {
            // After np. or numpy., suggest numpy methods
            suggestions = suggestions.filter(s => s.type === 'numpy');
        } else if (context.includes('plt.') || context.includes('matplotlib.')) {
            // After plt. or matplotlib., suggest matplotlib methods
            suggestions = suggestions.filter(s => s.type === 'matplotlib');
        } else if (context.includes('sqlite3.') || context.includes('conn.') || context.includes('cursor.')) {
            // For sqlite operations
            suggestions = suggestions.filter(s => s.type === 'sqlite');
        }
        
        // Better filtering - match anywhere in the word
        const filtered = suggestions.filter(s => 
            word.length === 0 || s.text.toLowerCase().includes(word.toLowerCase())
        );
        
        return {
            list: filtered.slice(0, 20), // Limit to 20 suggestions
            from: CodeMirror.Pos(cursor.line, start - word.length),
            to: CodeMirror.Pos(cursor.line, end)
        };
    });

    // R Autocomplete
    CodeMirror.registerHelper('hint', 'text/x-rsrc', function(editor, options) {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const start = cursor.ch;
        const end = cursor.ch;
        
        // Better word detection - handle different word boundaries and partial keywords
        const textBeforeCursor = line.substring(0, start);
        const wordMatch = textBeforeCursor.match(/\w*$/);
        const word = wordMatch ? wordMatch[0] : '';
        
        // Get context for better suggestions
        const context = textBeforeCursor.toLowerCase();
        
        const rKeywords = [
            // Control structures
            'if', 'else', 'for', 'in', 'while', 'repeat', 'next', 'break',
            // Functions
            'function', 'return', 'library', 'require', 'source',
            // Logical
            'TRUE', 'FALSE', 'NULL', 'NA', 'NaN', 'Inf',
            // Data types
            'numeric', 'integer', 'double', 'character', 'factor', 'logical',
            'matrix', 'array', 'data.frame', 'list', 'vector',
            // Basic functions
            'c', 'length', 'dim', 'str', 'summary', 'head', 'tail',
            'mean', 'median', 'sd', 'var', 'min', 'max', 'sum', 'prod',
            'sort', 'order', 'rank', 'unique', 'duplicated',
            // Data manipulation
            'subset', 'transform', 'merge', 'rbind', 'cbind',
            'apply', 'lapply', 'sapply', 'tapply', 'mapply',
            // Statistical functions
            'lm', 'glm', 'aov', 'anova', 'cor', 'cov', 't.test',
            'chisq.test', 'prop.test', 'wilcox.test',
            // Plotting
            'plot', 'hist', 'boxplot', 'barplot', 'pie', 'pairs',
            'abline', 'lines', 'points', 'text', 'title', 'legend',
            // Packages
            'dplyr', 'ggplot2', 'tidyr', 'readr', 'readxl', 'writexl',
            'lubridate', 'stringr', 'forcats', 'purrr', 'tibble',
            // Dplyr functions
            'filter', 'select', 'mutate', 'arrange', 'group_by', 'summarise',
            'left_join', 'right_join', 'inner_join', 'full_join',
            // Ggplot2 functions
            'ggplot', 'aes', 'geom_point', 'geom_line', 'geom_bar', 'geom_boxplot',
            'geom_histogram', 'labs', 'theme', 'scale_x_continuous', 'scale_y_continuous'
        ];
        
        const rFunctions = [
            'print()', 'cat()', 'paste()', 'paste0()', 'sprintf()',
            'read.csv()', 'read.table()', 'write.csv()', 'write.table()',
            'data.frame()', 'matrix()', 'array()', 'list()',
            'as.numeric()', 'as.character()', 'as.factor()', 'as.data.frame()',
            'is.na()', 'is.null()', 'is.numeric()', 'is.character()',
            'which()', 'which.max()', 'which.min()',
            'round()', 'ceiling()', 'floor()', 'trunc()',
            'abs()', 'sqrt()', 'log()', 'exp()', 'sin()', 'cos()', 'tan()'
        ];
        
        let suggestions = [
            ...rKeywords.map(k => ({text: k, displayText: k + ' (keyword)', type: 'keyword'})),
            ...rFunctions.map(f => ({text: f, displayText: f + ' (function)', type: 'function'}))
        ];
        
        // Context-aware filtering
        if (context.includes('library(') || context.includes('require(')) {
            // After library or require, suggest package names
            suggestions = suggestions.filter(s => 
                ['dplyr', 'ggplot2', 'tidyr', 'readr', 'readxl', 'writexl', 'lubridate', 'stringr', 'forcats', 'purrr', 'tibble'].includes(s.text)
            );
        } else if (context.includes('ggplot(') || context.includes('aes(')) {
            // After ggplot or aes, suggest ggplot functions
            suggestions = suggestions.filter(s => 
                ['geom_point', 'geom_line', 'geom_bar', 'geom_boxplot', 'geom_histogram', 'labs', 'theme'].includes(s.text)
            );
        } else if (context.includes('dplyr::') || context.includes('%>%')) {
            // After dplyr:: or pipe operator, suggest dplyr functions
            suggestions = suggestions.filter(s => 
                ['filter', 'select', 'mutate', 'arrange', 'group_by', 'summarise', 'left_join', 'right_join', 'inner_join', 'full_join'].includes(s.text)
            );
        }
        
        // Better filtering - match anywhere in the word
        const filtered = suggestions.filter(s => 
            word.length === 0 || s.text.toLowerCase().includes(word.toLowerCase())
        );
        
        return {
            list: filtered.slice(0, 20), // Limit to 20 suggestions
            from: CodeMirror.Pos(cursor.line, start - word.length),
            to: CodeMirror.Pos(cursor.line, end)
        };
    });

    // Register hint for text/x-python mode
    CodeMirror.registerHelper('hint', 'text/x-python', function(editor, options) {
        return CodeMirror.hint.python(editor, options);
    });

    // Register hint for text/x-rsrc mode
    CodeMirror.registerHelper('hint', 'text/x-rsrc', function(editor, options) {
        return CodeMirror.hint.r(editor, options);
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Add global error handlers
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('message port')) {
                console.warn('Global message port error caught:', event.error);
                event.preventDefault();
                return false;
            }
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            if (event.reason && event.reason.message && event.reason.message.includes('message port')) {
                console.warn('Unhandled promise rejection with message port error:', event.reason);
                event.preventDefault();
                return false;
            }
        });
        
        loadFromLocalStorage();
        loadSchema();
        
        // Add first cell if empty
        if (cells.length === 0) {
            addNewCell();
        }
    });

    function addNewCell() {
        cellIdCounter++;
        const cellId = 'cell-' + cellIdCounter;
        
        const cell = {
            id: cellId,
            type: 'sql',
            content: '',
            output: null,
            status: 'idle'
        };
        
        cells.push(cell);
        renderCell(cell);
        setActiveCell(cellId);
        saveToLocalStorage();
    }

    function renderCell(cell) {
        const container = document.getElementById('notebook-cells');
        
        const cellDiv = document.createElement('div');
        cellDiv.className = 'cell' + (cell.id === activeCellId ? ' active' : '');
        cellDiv.id = cell.id;
        
        cellDiv.innerHTML = `
            <div class="cell-header">
                <div class="cell-info">
                    <div class="cell-type-selector">
                        <button class="cell-type-btn ${cell.type === 'sql' ? 'active' : ''}" onclick="setCellType('${cell.id}', 'sql')">SQL</button>
                        <button class="cell-type-btn ${cell.type === 'python' ? 'active' : ''}" onclick="setCellType('${cell.id}', 'python')">Python</button>
                        <button class="cell-type-btn ${cell.type === 'r' ? 'active' : ''}" onclick="setCellType('${cell.id}', 'r')">R</button>
                    </div>
                    <span style="font-size: 11px; color: var(--text-muted);">Cell ${cells.indexOf(cell) + 1}</span>
                </div>
                <div class="cell-actions">
                    <button class="cell-action-btn run" onclick="runCell('${cell.id}')" title="Run">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="cell-action-btn" onclick="moveCellUp('${cell.id}')" title="Move Up">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                    <button class="cell-action-btn" onclick="moveCellDown('${cell.id}')" title="Move Down">
                        <i class="fas fa-arrow-down"></i>
                    </button>
                    <button class="cell-action-btn" onclick="deleteCell('${cell.id}')" title="Delete">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
            <div class="cell-content">
                <div class="cell-editor" id="${cell.id}-editor"></div>
                <div class="cell-output ${cell.output ? 'show' : ''}" id="${cell.id}-output">
                    ${cell.output || ''}
                </div>
            </div>
        `;
        
        container.appendChild(cellDiv);
        
        // Initialize CodeMirror
        setTimeout(() => {
            const editor = CodeMirror(document.getElementById(cell.id + '-editor'), {
                mode: cell.type === 'python' ? 'text/x-python' : cell.type === 'r' ? 'text/x-rsrc' : 'text/x-sql',
                theme: 'material-darker',
                lineNumbers: true,
                lineWrapping: true,
                indentUnit: 4,
                matchBrackets: true,
                autoCloseBrackets: true,
                extraKeys: {
                    'Ctrl-Enter': () => runCell(cell.id),
                    'Shift-Enter': () => runCellAndAddNew(cell.id),
                    'Ctrl-Space': (cm) => cm.showHint({hint: CodeMirror.hint.auto}),
                    'Tab': 'indentMore',
                    'Shift-Tab': 'indentLess',
                    '.': (cm) => {
                        cm.replaceSelection('.');
                        // Trigger autocomplete after dot for Python
                        if (cell.type === 'python') {
                            setTimeout(() => {
                                cm.showHint({hint: CodeMirror.hint.auto, completeSingle: false});
                            }, 100);
                        }
                    }
                },
                hintOptions: {
                    completeSingle: false,
                    closeOnUnfocus: false
                }
            });
            
            editor.setValue(cell.content);
            cell.editor = editor;
            
            editor.on('change', () => {
                cell.content = editor.getValue();
                saveToLocalStorage();
                
                // Enhanced auto-trigger autocomplete - only on typing letters/numbers
                const cursor = editor.getCursor();
                const line = editor.getLine(cursor.line);
                const textBeforeCursor = line.substring(0, cursor.ch);
                
                // Only trigger after 1 character and only if last character is alphanumeric
                if (textBeforeCursor.length >= 1) {
                    const lastChar = textBeforeCursor[textBeforeCursor.length - 1];
                    const lastWord = textBeforeCursor.match(/\w*$/);
                    
                    // Only trigger if last character is letter/number, NOT space, and we have a word
                    if (lastChar !== ' ' && lastChar !== '\t' && /[a-zA-Z0-9]/.test(lastChar) && lastWord && lastWord[0].length >= 1) {
                        // Don't trigger too frequently
                        clearTimeout(editor._autocompleteTimeout);
                        editor._autocompleteTimeout = setTimeout(() => {
                            // Only show hints when actively typing letters/numbers
                            editor.showHint({hint: CodeMirror.hint.auto, completeSingle: false});
                        }, 200);
                    }
                }
            });
            
            // Remove cursor activity trigger to avoid unwanted popups
            // editor.on('cursorActivity', () => { ... });
            
            editor.on('focus', () => {
                setActiveCell(cell.id);
            });
            
            // Auto-resize
            function resize() {
                const lines = editor.getValue().split('\n').length;
                const height = Math.max(80, lines * 22 + 20);
                editor.getWrapperElement().style.height = height + 'px';
                editor.refresh();
            }
            
            resize();
            editor.on('change', resize);
        }, 10);
    }

    function setActiveCell(cellId) {
        activeCellId = cellId;
        
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('active'));
        const cell = document.getElementById(cellId);
        if (cell) cell.classList.add('active');
        
        updateCellInfo(cellId);
    }

    function updateCellInfo(cellId) {
        const cell = cells.find(c => c.id === cellId);
        if (!cell) return;
        
        const infoEl = document.getElementById('cell-info');
        if (!infoEl) return; // Element not found in new layout
        
        infoEl.innerHTML = `
            <div><strong>Type:</strong> ${cell.type.toUpperCase()}</div>
            <div><strong>Status:</strong> ${cell.status}</div>
            <div><strong>Lines:</strong> ${cell.content ? cell.content.split('\n').length : 0}</div>
        `;
    }

    function setCellType(cellId, type) {
        const cell = cells.find(c => c.id === cellId);
        if (!cell) return;
        
        cell.type = type;
        if (cell.editor) {
            cell.editor.setOption('mode', type === 'python' ? 'text/x-python' : type === 'r' ? 'text/x-rsrc' : 'text/x-sql');
        }
        
        // Update UI
        const cellDiv = document.getElementById(cellId);
        const buttons = cellDiv.querySelectorAll('.cell-type-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase() === type);
        });
        
        saveToLocalStorage();
    }

    async function runCell(cellId) {
        const cell = cells.find(c => c.id === cellId);
        if (!cell || !cell.content.trim()) return;
        
        cell.status = 'running';
        updateCellInfo(cellId);
        
        try {
            let result;
            if (cell.type === 'sql') {
                result = await executeSQL(cell.content);
            } else {
                result = await executePython(cell.content);
            }
            
            cell.output = result;
            cell.status = 'success';
            
            const outputDiv = document.getElementById(cellId + '-output');
            outputDiv.innerHTML = result;
            outputDiv.classList.add('show');
        } catch (error) {
            cell.status = 'error';
            const errorHtml = '<div class="output-error"><i class="fas fa-exclamation-circle"></i> ' + error.message + '</div>';
            cell.output = errorHtml;
            
            const outputDiv = document.getElementById(cellId + '-output');
            outputDiv.innerHTML = errorHtml;
            outputDiv.classList.add('show');
        }
        
        updateCellInfo(cellId);
        saveToLocalStorage();
    }

    function runCellAndAddNew(cellId) {
        runCell(cellId).then(() => {
            const index = cells.findIndex(c => c.id === cellId);
            if (index === cells.length - 1) {
                addNewCell();
            }
        });
    }

    function runCurrentCell() {
        if (activeCellId) runCell(activeCellId);
    }

    async function runAllCells() {
        for (const cell of cells) {
            if (cell.content.trim()) {
                await runCell(cell.id);
            }
        }
    }

    function clearAllOutputs() {
        cells.forEach(cell => {
            cell.output = null;
            cell.status = 'idle';
            const outputDiv = document.getElementById(cell.id + '-output');
            if (outputDiv) {
                outputDiv.innerHTML = '';
                outputDiv.classList.remove('show');
            }
        });
        saveToLocalStorage();
    }

    function deleteCell(cellId) {
        if (cells.length <= 1) {
            alert('Cannot delete the last cell');
            return;
        }
        
        const index = cells.findIndex(c => c.id === cellId);
        if (index === -1) return;
        
        cells.splice(index, 1);
        document.getElementById(cellId).remove();
        
        if (activeCellId === cellId) {
            const newCell = cells[Math.min(index, cells.length - 1)];
            if (newCell) setActiveCell(newCell.id);
        }
        
        renumberCells();
        saveToLocalStorage();
    }

    function moveCellUp(cellId) {
        const index = cells.findIndex(c => c.id === cellId);
        if (index <= 0) return;
        
        [cells[index - 1], cells[index]] = [cells[index], cells[index - 1]];
        reRenderAllCells();
    }

    function moveCellDown(cellId) {
        const index = cells.findIndex(c => c.id === cellId);
        if (index >= cells.length - 1) return;
        
        [cells[index], cells[index + 1]] = [cells[index + 1], cells[index]];
        reRenderAllCells();
    }

    function reRenderAllCells() {
        const container = document.getElementById('notebook-cells');
        container.innerHTML = '';
        cells.forEach(cell => renderCell(cell));
        renumberCells();
    }

    function renumberCells() {
        cells.forEach((cell, index) => {
            const cellDiv = document.getElementById(cell.id);
            if (cellDiv) {
                const label = cellDiv.querySelector('.cell-info span');
                if (label) label.textContent = 'Cell ' + (index + 1);
            }
        });
    }

    async function executeSQL(query) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch('/query/execute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = safeJSONParse(await response.text(), "executeSQL");
            
            if (!result || !result.success) {
                return '<div class="output-error"><i class="fas fa-exclamation-circle"></i> ' + result.message + '</div>';
            }
            
            if (result.has_results) {
                return renderTableOutput(result.columns, result.data, result.row_count);
            } else {
                return '<div class="output-success"><i class="fas fa-check-circle"></i> ' + result.message + '</div>';
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                return '<div class="output-error"><i class="fas fa-clock"></i> Query timed out after 30 seconds</div>';
            }
            if (error.message && error.message.includes('message port')) {
                console.warn('Message port error detected, retrying...');
                // Retry once after a short delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                try {
                    return await executeSQL(query);
                } catch (retryError) {
                    return '<div class="output-error"><i class="fas fa-exclamation-circle"></i> Communication error: ' + retryError.message + '</div>';
                }
            }
            return '<div class="output-error"><i class="fas fa-exclamation-circle"></i> ' + error.message + '</div>';
        }
    }

    async function executePython(code) {
        try {
            // Check if we have a valid connection first
            if (!navigator.onLine) {
                return '<div class="output-error"><i class="fas fa-wifi"></i> No internet connection</div>';
            }
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch('/query/execute-python', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ code: code || '' }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                const errorText = await response.text();
                let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                
                // Try to parse error details from server
                try {
                    const errorData = JSON.parse(errorText);
                    if (errorData.message) {
                        errorMessage = errorData.message;
                    }
                } catch (e) {
                    // If not JSON, use the raw error text
                    if (errorText && errorText.trim()) {
                        errorMessage = errorText;
                    }
                }
                
                throw new Error(errorMessage);
            }
            
            const result = safeJSONParse(await response.text(), "executePython");
            if (!result || !result.success) {
                return '<div class="output-error"><pre class="output-text">' + (result?.message || result?.error || 'Execution error') + '</pre></div>';
            }
            
            if (result && result.output_type === 'table') {
                return renderTableOutput(result.columns, result.data, result.data.length);
            } else if (result && result.output_type === 'plot') {
                return '<div class="output-content"><img src="data:image/png;base64,' + result.image_data + '" style="max-width: 100%; height: auto;"></div>';
            } else {
                return '<div class="output-content"><pre class="output-text">' + (result.output || 'Code executed successfully') + '</pre></div>';
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                return '<div class="output-error"><i class="fas fa-clock"></i> Python execution timed out after 30 seconds</div>';
            }
            if (error.message && error.message.includes('message port')) {
                console.warn('Message port error detected in Python execution, retrying...');
                // Retry once after a short delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                try {
                    return await executePython(code);
                } catch (retryError) {
                    return '<div class="output-error"><i class="fas fa-exclamation-circle"></i> Communication error: ' + retryError.message + '</div>';
                }
            }
            if (error.message && error.message.includes('Failed to fetch')) {
                return '<div class="output-error"><i class="fas fa-server"></i> Server connection failed. Please check if the server is running.</div>';
            }
            return '<div class="output-error"><i class="fas fa-exclamation-circle"></i> ' + error.message + '</div>';
        }
    }

    function renderTableOutput(columns, data, rowCount) {
        if (!data || data.length === 0) {
            return '<div class="output-content"><div class="output-success">Query executed successfully. No rows returned.</div></div>';
        }
        
        let html = '<div class="output-header">Results (' + rowCount + ' rows)</div>';
        html += '<div class="output-content"><table class="output-table"><thead><tr>';
        
        columns.forEach(col => {
            html += '<th>' + col + '</th>';
        });
        html += '</tr></thead><tbody>';
        
        data.slice(0, 100).forEach(row => {
            html += '<tr>';
            columns.forEach(col => {
                const val = row[col] !== null && row[col] !== undefined ? row[col] : '';
                html += '<td>' + val + '</td>';
            });
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        if (data.length > 100) {
            html += '<div style="padding: 8px; color: var(--text-muted); font-size: 12px;">Showing first 100 of ' + data.length + ' rows</div>';
        }
        html += '</div>';
        
        return html;
    }

    function saveToLocalStorage() {
        const data = cells.map(c => ({
            id: c.id,
            type: c.type,
            content: c.content,
            output: c.output,
            status: c.status
        }));
        localStorage.setItem('notebook', JSON.stringify(data));
    }

    function loadFromLocalStorage() {
        const saved = localStorage.getItem('notebook');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                data.forEach(c => {
                    cellIdCounter = Math.max(cellIdCounter, parseInt(c.id.split('-')[1]));
                    cells.push({
                        id: c.id,
                        type: c.type || 'sql',
                        content: c.content || '',
                        output: c.output || null,
                        status: c.status || 'idle'
                    });
                });
                cells.forEach(cell => renderCell(cell));
            } catch (e) {
                console.error('Failed to load notebook:', e);
            }
        }
    }

    async function loadSchema() {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
            
            const response = await fetch('/query/schema', {
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = safeJSONParse(await response.text(), "loadSchema");
            if (result && result.success) {
                // Store database tables for autocomplete
                databaseTables = result.tables;
                
                // Fetch columns for each table
                if (result && result.tables) {
                    for (const table of result.tables) {
                        try {
                            const colController = new AbortController();
                            const colTimeoutId = setTimeout(() => colController.abort(), 5000); // 5 second timeout per table
                            
                            const colResponse = await fetch(`/query/schema/${table}`, {
                                signal: colController.signal
                            });
                            
                            clearTimeout(colTimeoutId);
                            
                            if (colResponse.ok) {
                                const colText = await colResponse.text();
                                let colResult;
                                try {
                                    colResult = JSON.parse(colText);
                                } catch (parseError) {
                                    console.error('JSON parse error in column loading:', parseError);
                                    console.error('Response text:', colText);
                                    return;
                                }
                                if (colResult.success) {
                                    tableColumns[table] = colResult.columns;
                                }
                            }
                        } catch (e) {
                            console.warn(`Failed to fetch columns for table ${table}:`, e);
                        }
                    }
                }
                
                const container = document.getElementById('schema-list');
                container.innerHTML = '';
                
                if (result && result.tables) {
                    result.tables.forEach(table => {
                        const div = document.createElement('div');
                        div.className = 'schema-item';
                        div.innerHTML = '<i class="fas fa-table" style="margin-right: 8px;"></i>' + table;
                        div.onclick = () => insertTableName(table);
                        container.appendChild(div);
                    });
                }
            } else {
                throw new Error((result && result.message) || 'Failed to load schema');
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.error('Schema loading timed out');
            } else if (error.message && error.message.includes('message port')) {
                console.warn('Message port error in schema loading, retrying...');
                // Retry once after a short delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                try {
                    return await loadSchema();
                } catch (retryError) {
                    console.error('Failed to retry schema loading:', retryError);
                }
            }
            console.error('Failed to load schema:', error);
            
            const container = document.getElementById('schema-list');
            container.innerHTML = '<div style="text-align: center; padding: 12px; color: var(--text-muted);">Failed to load schema</div>';
        }
    }

    function insertTableName(tableName) {
        if (activeCellId) {
            const cell = cells.find(c => c.id === activeCellId);
            if (cell && cell.editor) {
                cell.editor.replaceSelection(tableName);
                cell.editor.focus();
            }
        }
    }

    function saveNotebook() {
        const data = cells.map(c => ({
            type: c.type,
            content: c.content
        }));
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'notebook.json';
        a.click();
        URL.revokeObjectURL(url);
    }

    // File Browser Functions
    let currentPath = '';
    let workspaceFiles = [];

    async function loadFileBrowser() {
        try {
            const response = await fetch(`/query/notebook/files?path=${encodeURIComponent(currentPath)}`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const text = await response.text();
            
            // Check if response is empty
            if (!text) {
                throw new Error('Empty response from server');
            }
            
            let result;
            try {
                result = JSON.parse(text);
            } catch (parseError) {
                console.error('JSON parse error:', parseError);
                console.error('Response text:', text);
                document.getElementById('file-browser').innerHTML = 
                    '<div style="text-align: center; padding: 12px; color: var(--accent-danger);">Invalid response from server</div>';
                return;
            }
            
            if (result && result.success) {
                workspaceFiles = result.items || [];
                renderFileBrowser();
            } else {
                document.getElementById('file-browser').innerHTML = 
                    `<div style="text-align: center; padding: 12px; color: var(--accent-danger);">${result.message || 'Failed to load files'}</div>`;
            }
        } catch (e) {
            console.error('Error loading files:', e);
            document.getElementById('file-browser').innerHTML = 
                '<div style="text-align: center; padding: 12px; color: var(--accent-danger);">Network error loading files</div>';
        }
    }

    function renderFileBrowser() {
        const container = document.getElementById('file-browser');
        const breadcrumb = document.getElementById('file-breadcrumb');
        
        if (!container) return; // Element not found, exit
        
        // Update breadcrumb if it exists
        if (breadcrumb) {
            breadcrumb.textContent = currentPath || '/';
        }
        
        container.innerHTML = '';
        
        // Add ".." entry if not at root
        if (currentPath) {
            const parentDiv = document.createElement('div');
            parentDiv.className = 'file-item directory';
            parentDiv.innerHTML = '<i class="fas fa-level-up-alt"></i><span>..</span>';
            parentDiv.onclick = () => navigateToParent();
            container.appendChild(parentDiv);
        }
        
        if (workspaceFiles.length === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.style.cssText = 'text-align: center; padding: 12px; color: var(--text-muted);';
            emptyDiv.textContent = 'Empty folder';
            container.appendChild(emptyDiv);
            return;
        }
        
        workspaceFiles.forEach(item => {
            const div = document.createElement('div');
            div.className = `file-item ${item.type}`;
            
            const icon = item.type === 'directory' ? 'fa-folder' : getFileIcon(item.extension);
            div.innerHTML = `<i class="fas ${icon}"></i><span>${item.name}</span>`;
            
            // Store file data for context menu
            div.dataset.filePath = item.path;
            div.dataset.fileName = item.name;
            div.dataset.fileType = item.type;
            
            if (item.type === 'directory') {
                div.onclick = () => navigateToFolder(item.path);
            } else {
                div.onclick = () => insertFilePath(item.path);
                div.title = 'Click to insert path in cell';
            }
            
            // Add context menu
            div.oncontextmenu = (e) => showFileContextMenu(e, item);
            
            container.appendChild(div);
        });
    }

    function getFileIcon(ext) {
        const iconMap = {
            '.csv': 'fa-file-csv',
            '.xlsx': 'fa-file-excel',
            '.xls': 'fa-file-excel',
            '.json': 'fa-file-code',
            '.py': 'fa-file-code',
            '.sql': 'fa-database',
            '.md': 'fa-file-alt',
            '.txt': 'fa-file-alt',
            '.png': 'fa-file-image',
            '.jpg': 'fa-file-image',
            '.jpeg': 'fa-file-image',
            '.pdf': 'fa-file-pdf'
        };
        return iconMap[ext] || 'fa-file';
    }

    function navigateToFolder(path) {
        currentPath = path;
        loadFileBrowser();
    }

    function navigateToParent() {
        const parts = currentPath.split('/').filter(p => p);
        parts.pop();
        currentPath = parts.join('/');
        loadFileBrowser();
    }

    function insertFilePath(path) {
        if (activeCellId) {
            const cell = cells.find(c => c.id === activeCellId);
            if (cell && cell.editor) {
                const workspace = '~/.haoxai/notebook_workspace';
                const fullPath = `${workspace}/${path}`;
                cell.editor.replaceSelection(`'${fullPath}'`);
                cell.editor.focus();
            }
        }
    }

    async function refreshFileBrowser() {
        await loadFileBrowser();
        await loadWorkspaceInfo();
    }

    async function loadWorkspaceInfo() {
        try {
            const response = await fetch('/query/notebook/workspace-info');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const text = await response.text();
            
            if (!text) {
                throw new Error('Empty response from server');
            }
            
            let result;
            try {
                result = JSON.parse(text);
            } catch (parseError) {
                console.error('JSON parse error in workspace info:', parseError);
                console.error('Response text:', text);
                return;
            }
            
            if (result && result.success) {
                const infoEl = document.getElementById('workspace-info');
                if (infoEl) {
                    infoEl.textContent = `${result.file_count || 0} files, ${result.total_size_human || '0 B'}`;
                }
            }
        } catch (e) {
            console.error('Error loading workspace info:', e);
        }
    }

    function triggerFileUpload() {
        document.getElementById('file-upload-input').click();
    }

    async function handleFileUpload(input) {
        if (!input.files || input.files.length === 0) return;
        
        const file = input.files[0];
        const formData = new FormData();
        formData.append('file', file);
        formData.append('path', currentPath);
        
        try {
            const response = await fetch('/query/notebook/files/upload', {
                method: 'POST',
                body: formData
            });
            
            const result = safeJSONParse(await response.text(), "handleFileUpload");
            if (result && result.success) {
                loadFileBrowser();
                loadWorkspaceInfo();
            } else {
                alert('Upload failed: ' + (result.message || 'Unknown error'));
            }
        } catch (e) {
            console.error('Upload error:', e);
            alert('Upload failed');
        }
        
        // Reset input
        input.value = '';
    }

    async function createNewFolder() {
        const name = prompt('Enter folder name:');
        if (!name) return;
        
        try {
            const response = await fetch('/query/notebook/files/mkdir', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: currentPath, name })
            });
            
            const result = safeJSONParse(await response.text(), "createNewFolder");
            if (result && result.success) {
                loadFileBrowser();
            } else {
                alert('Failed: ' + (result.message || 'Unknown error'));
            }
        } catch (e) {
            console.error('Error creating folder:', e);
        }
    }

    // Drag and drop support
    const uploadArea = document.getElementById('upload-area');
    if (uploadArea) {
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            
            if (e.dataTransfer.files.length > 0) {
                const input = document.getElementById('file-upload-input');
                input.files = e.dataTransfer.files;
                handleFileUpload(input);
            }
        });
    }

    // Package Manager Variables
    let currentPackageLanguage = 'python';

    function setPackageLanguage(lang) {
        currentPackageLanguage = lang;
        
        // Update button states
        document.querySelectorAll('.package-lang-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.lang === lang);
        });
        
        // Show/hide R configuration section
        const rConfigSection = document.getElementById('r-config-section');
        if (lang === 'r') {
            rConfigSection.style.display = 'block';
            loadRPath(); // Load saved R path
        } else {
            rConfigSection.style.display = 'none';
        }
        
        // Update placeholder
        const input = document.getElementById('pip-package-input');
        if (lang === 'r') {
            input.placeholder = 'dplyr, ggplot2, tidyr...';
        } else {
            input.placeholder = 'numpy, pandas, scipy...';
        }
        
        // Clear previous output
        const output = document.getElementById('pip-output');
        output.style.display = 'none';
        output.textContent = '';
    }

    function loadRPath() {
        const savedPath = localStorage.getItem('rscript_path') || '';
        const rPathInput = document.getElementById('r-path-input');
        if (rPathInput) {
            rPathInput.value = savedPath;
        }
    }

    function saveRPath() {
        const rPathInput = document.getElementById('r-path-input');
        const rPath = rPathInput.value.trim();
        
        if (!rPath) {
            alert('Please enter a valid Rscript path');
            return;
        }
        
        // Save to localStorage
        localStorage.setItem('rscript_path', rPath);
        
        // Show success feedback
        const originalValue = rPathInput.value;
        rPathInput.style.borderColor = 'var(--accent-success)';
        rPathInput.value = 'Saved!';
        
        setTimeout(() => {
            rPathInput.style.borderColor = '';
            rPathInput.value = originalValue;
        }, 1500);
    }

    // Pip Install Functions
    async function installPackage() {
        const input = document.getElementById('pip-package-input');
        const output = document.getElementById('pip-output');
        const package = input.value.trim();
        
        if (!package) {
            alert('Please enter a package name');
            return;
        }
        
        output.style.display = 'block';
        output.className = 'pip-output';
        
        const installText = currentPackageLanguage === 'r' ? `Installing R package ${package}...` : `Installing Python package ${package}...`;
        output.textContent = installText;
        
        try {
            let endpoint, payload;
            
            if (currentPackageLanguage === 'r') {
                endpoint = '/query/notebook/r-install';
                const rPath = localStorage.getItem('rscript_path') || '';
                if (!rPath) {
                    output.classList.add('error');
                    output.textContent = 'Please configure Rscript path in R Configuration section';
                    return;
                }
                payload = { package, r_path: rPath };
            } else {
                endpoint = '/query/notebook/pip-install';
                payload = { package };
            }
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = safeJSONParse(await response.text(), "installPackage");
            
            if (result && result.success) {
                output.classList.add('success');
                output.textContent = result.output || `Successfully installed ${package}`;
                input.value = '';
            } else {
                output.classList.add('error');
                output.textContent = ((result && result.error) || (result && result.message) || 'Installation failed');
            }
        } catch (e) {
            output.classList.add('error');
            output.textContent = 'Error: ' + e.message;
        }
    }

    // IDE Navigation Functions
    function showSidebar(view) {
        // Hide all sidebar views
        document.querySelectorAll('.sidebar-view').forEach(v => v.style.display = 'none');
        // Show selected view
        document.getElementById('sidebar-' + view).style.display = 'block';
        // Update activity bar
        document.querySelectorAll('.activity-item').forEach(i => i.classList.remove('active'));
        event.currentTarget.classList.add('active');
    }

    function toggleSection(header) {
        const content = header.nextElementSibling;
        if (content) {
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
        }
        const icon = header.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-chevron-right');
            icon.classList.toggle('fa-chevron-down');
        }
    }

    function toggleSettings() {
        alert('Settings panel coming soon!');
    }

    // Missing functions that were referenced
    function updateStatus(message) {
        const statusEl = document.getElementById('status-bar');
        if (statusEl) {
            statusEl.textContent = message;
        }
    }

    function updateConnectionStatus(status) {
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = status;
        }
    }

    // Initialize file browser on load
    document.addEventListener('DOMContentLoaded', () => {
        // Force cache refresh
        const timestamp = new Date().getTime();
        const scripts = document.querySelectorAll('script[src]');
        scripts.forEach(script => {
            if (script.src.includes('notebook_editor.html')) {
                // Skip inline scripts
                return;
            }
        });
        
        loadFileBrowser();
        loadWorkspaceInfo();
    });
</script>

<!-- File Context Menu -->
<div id="file-context-menu" class="context-menu" style="display: none;">
    <div class="context-menu-item" onclick="renameFile()">
        <i class="fas fa-edit"></i> Rename
    </div>
    <div class="context-menu-item" onclick="copyFile()">
        <i class="fas fa-copy"></i> Copy
    </div>
    <div class="context-menu-item" onclick="moveFile()">
        <i class="fas fa-arrows-alt"></i> Move
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item danger" onclick="deleteFile()">
        <i class="fas fa-trash"></i> Delete
    </div>
</div>

<style>
.context-menu {
    position: fixed;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 0;
    min-width: 150px;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
    font-size: 12px;
}

.context-menu-item:hover {
    background: var(--bg-hover);
}

.context-menu-item.danger {
    color: var(--accent-danger);
}

.context-menu-separator {
    height: 1px;
    background: var(--border-color);
    margin: 4px 0;
}
</style>

<script>
let selectedFile = null;
let selectedFilePath = '';

function showFileContextMenu(event, file) {
    event.preventDefault();
    event.stopPropagation();
    
    selectedFile = file;
    selectedFilePath = file.path;
    
    const menu = document.getElementById('file-context-menu');
    menu.style.display = 'block';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    
    // Hide menu when clicking elsewhere
    document.addEventListener('click', hideContextMenu);
}

function hideContextMenu() {
    const menu = document.getElementById('file-context-menu');
    menu.style.display = 'none';
    document.removeEventListener('click', hideContextMenu);
}

async function renameFile() {
    if (!selectedFile) return;
    
    const newName = prompt('Enter new name:', selectedFile.name);
    if (!newName || newName === selectedFile.name) {
        hideContextMenu();
        return;
    }
    
    try {
        const response = await fetch('/query/notebook/file/rename', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                old_path: selectedFilePath,
                new_name: newName
            })
        });
        
        const result = await response.json();
        if (result.success) {
            updateStatus(`Renamed to ${newName}`);
            await refreshFileBrowser();
        } else {
            alert(`Error: ${result.message}`);
        }
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
    
    hideContextMenu();
}

async function deleteFile() {
    if (!selectedFile) return;
    
    if (!confirm(`Are you sure you want to delete "${selectedFile.name}"?`)) {
        hideContextMenu();
        return;
    }
    
    try {
        const response = await fetch('/query/notebook/file/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                path: selectedFilePath
            })
        });
        
        const result = await response.json();
        if (result.success) {
            updateStatus(`Deleted ${selectedFile.name}`);
            await refreshFileBrowser();
        } else {
            alert(`Error: ${result.message}`);
        }
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
    
    hideContextMenu();
}

async function copyFile() {
    if (!selectedFile) return;
    
    // For now, we'll implement a simple copy to current directory
    // In a full implementation, you'd show a dialog to select target directory
    try {
        const response = await fetch('/query/notebook/file/copy', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                source_path: selectedFilePath,
                target_dir: currentPath || '.'
            })
        });
        
        const result = await response.json();
        if (result.success) {
            updateStatus(`Copied ${selectedFile.name}`);
            await refreshFileBrowser();
        } else {
            alert(`Error: ${result.message}`);
        }
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
    
    hideContextMenu();
}

async function moveFile() {
    if (!selectedFile) return;
    
    // For now, we'll implement a simple move within current directory
    // In a full implementation, you'd show a dialog to select target directory
    const newName = prompt('Enter new location (relative to current directory):', selectedFile.name);
    if (!newName) {
        hideContextMenu();
        return;
    }
    
    try {
        const response = await fetch('/query/notebook/file/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                source_path: selectedFilePath,
                target_dir: currentPath || '.'
            })
        });
        
        const result = await response.json();
        if (result.success) {
            updateStatus(`Moved ${selectedFile.name}`);
            await refreshFileBrowser();
        } else {
            alert(`Error: ${result.message}`);
        }
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
    
    hideContextMenu();
}
</script>
{% endblock %}
